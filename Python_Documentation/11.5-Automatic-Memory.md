
# Concept 11.5: Automatic Memory (The Garbage Collector)

## 1. Deep Explanation (The Logic)
In Python, you don't manually manage the "Warehouse" (Heap). Python hires a manager to do it for you.

### The Heap (The Warehouse) üè≠
In Python: **Almost EVERYTHING lives in the Heap.**
Every time you create a list `[1, 2, 3]` or an object `Robot()`, Python automatically finds space in the huge Warehouse (Heap) and puts it there.

### The Garbage Collector (The Manager) ‚ôªÔ∏è
* **The Problem:** If you keep creating objects but never clean them up, the Warehouse gets full (RAM fills up).
* **The Solution:** Python has a background process called the **Garbage Collector (GC)**.



### How it works (Reference Counting):
1.  The GC watches every object.
2.  It counts how many **"Name Tags" (Variables)** are attached to that object.
3.  **The Rule:** If the count drops to **Zero** (no one is using this object anymore), the GC immediately destroys it and frees the memory.

---

## 2. Why do we use it?
1.  **Safety:** You can't accidentally delete an object while someone else is using it (which causes crashes in lower-level languages).
2.  **Simplicity:** You focus on logic, not memory addresses. You don't need to write `delete` or `free`.

---

## 3. Syntax (Creation & "Deletion")

### A. Allocation (Creation)
You just define the variable. Python handles the memory request secretly.

```python
# Python automatically asks the OS for memory
my_list = [0] * 1000000 

```

### B. Deallocation (The `del` keyword)

You rarely need to delete objects manually. However, you can use the `del` keyword.

> **Important:** `del x` does **not** delete the object. It deletes the **Name Tag (Reference)**.
> If `x` was the *only* tag, the Ref Count becomes 0, and the GC eats the object.

```python
x = [1, 2, 3] # Object created. Ref Count = 1.
del x         # Tag removed. Ref Count = 0. Object destroyed.

```

---

## 4. The Trap: "The Memory Leak" (Zombie Objects) ‚ö†Ô∏è

Even with a Garbage Collector, you can still leak memory in Python.

* **The Scenario:** You have a global list called `history`.
* **The Loop:** Every time your sensor reads data, you `history.append(data)`.
* **The Leak:** You never clear this list.
* **The Result:** Even though you are done with the old data, the `history` list still holds a "Tag" on it. The Ref Count never reaches zero. The GC cannot delete it. **Your RAM eventually fills up.**

---

## 5. Code Example

This code demonstrates how the Garbage Collector works using `__del__` (the destructor) to prove when objects die.

```python
class DataPacket:
    def __init__(self, id):
        self.id = id
        print(f"Packet {self.id} created (Allocated).")

    # This runs when the Garbage Collector destroys the object
    def __del__(self):
        print(f"Packet {self.id} destroyed (Freed).")

def create_temporary_data():
    print("--- Function Start ---")
    # 1. Create Object
    # 'p' is a reference (Tag) to the object
    p = DataPacket(100) 
    
    print("--- Function End ---")
    # 2. Scope Ends
    # The variable 'p' is removed.
    # The Object now has 0 references.
    # The Garbage Collector destroys it automatically here.

# Main Execution
print("Step 1: Calling function...")
create_temporary_data()
print("Step 2: Back in Main.")

```

---

## 6. ROS2 Context: "The Sensor Buffer"

In ROS2 nodes, be very careful with Lists inside Classes.

**Dangerous Pattern:**

```python
class LidarNode(Node):
    def __init__(self):
        self.all_scans = [] # <--- DANGER

    def callback(self, msg):
        # If you do this forever, the robot runs out of RAM
        self.all_scans.append(msg) 

```

**The Fix:** If you only need the last 10 scans, verify the size and pop the old ones.

```python
    def callback(self, msg):
        self.all_scans.append(msg)
        if len(self.all_scans) > 10:
            self.all_scans.pop(0) # Remove the oldest tag so GC can eat it

```

---

## 7. Task: "The RAM Filler" ‚úÖ

**Scenario:**
You want to simulate a memory management situation. You will create a "Database" list, fill it, and then manually clear it to free space.

**Requirements:**

1. Create a class `BigObject` that prints "Born" in `__init__` and "Died" in `__del__`.
2. Create a list `database = []`.
3. **The Logic:**
* Create a loop that runs 3 times.
* Inside the loop, create a `BigObject` and append it to `database`.
* Print "End of Loop".


4. **The Cleanup:**
* Outside the loop, print "Clearing Database...".
* Call `database.clear()`.
* Print "Program End".



**Observation:**

* You will see 3 "Born" messages.
* You **won't** see "Died" immediately because they are trapped in the list.
* After "Clearing Database", you should see 3 "Died" messages appear.

*This proves that removing the references allows the Garbage Collector to do its job.*
